//This is going to make <partition>_main.cpp, which is the simulation interface of the partition's MPI process

#ifndef V3METRO_MPI_PART_LIB_H
#define V3METRO_MPI_PART_LIB_H

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <tuple>
#include <stdexcept>
#include <algorithm>

// This header requires the nlohmann/json library.
// It is assumed to be available in your project's include path.
#include "json.h"

using json = nlohmann::json;

/**
 * @class MPIMainGenerator
 * @brief Generates a standalone C++ main file for an MPI partition process.
 * @details This class reads a JSON report and creates a complete, compilable
 * C++ program that acts as the simulation driver for a single partition.
 * The generated program handles MPI communication, Verilated model instantiation,
 * and the main simulation loop.
 */
class MPIMainGenerator {
private:
    // Represents a single point-to-point connection between two ports
    struct P2P_Link {
        std::string receiver_partition_name;
        int receiver_rank;
        std::string receiver_port_name;
        int receiver_port_width;
        std::string sender_instance_name;
        int sender_rank;
        std::string sender_port_name;
    };

    // Maps a {sender_rank, receiver_rank} pair to a list of connections
    using CommunicationGraph = std::map<std::pair<int, int>, std::vector<P2P_Link>>;

    // Holds the initialization value for a single port.
    struct InitPortInfo {
        std::string port_name;
        std::string init_value; // Stores a C++ compatible literal (e.g., "0xF")
    };

    // Holds all initialization info for a single partition instance.
    struct PartitionInfo {
        std::string instance_name;
        int mpi_rank;
        std::vector<InitPortInfo> init_ports;
    };

    /**
     * @brief Converts a Verilog-style string literal (e.g., "8'hF")
     * into a C++ compatible integer literal string (e.g., "0xF").
     */
    std::string verilog_to_cpp_literal(const std::string& verilog_literal) {
        size_t apos_pos = verilog_literal.find('\'');
        if (apos_pos == std::string::npos) {
            return verilog_literal; // Assume it's a simple number
        }
        std::string val_part = verilog_literal.substr(apos_pos + 1);
        char base_char = val_part[0];
        std::string number_str;

        if (base_char == 's' || base_char == 'S') {
            base_char = val_part[1];
            number_str = val_part.substr(2);
        } else {
            number_str = val_part.substr(1);
        }

        switch (base_char) {
            case 'h': case 'H': return "0x" + number_str;
            case 'd': case 'D': return number_str;
            case 'b': case 'B': return "0b" + number_str;
            case 'o': case 'O': return "0" + number_str; // Octal
            default: return verilog_literal; // Fallback
        }
    }

    /**
     * @brief The core function that generates the standalone C++ main file.
     */
    void generateStandaloneMain(
        const std::string& partitionModuleName,
        const std::map<std::string, PartitionInfo>& partitions,
        const CommunicationGraph& commGraph,
        const std::set<int>& all_ranks,
        const std::string& outputDir) {

        std::string outFileName = outputDir + "/" + partitionModuleName + "_main.cpp";
        std::ofstream outFile(outFileName);
        if (!outFile.is_open()) {
            throw std::runtime_error("Error [MPIMainGenerator]: Could not open output file " + outFileName);
        }

        outFile << "// Generated by Metro-MPI\n\n";
        outFile << "#include <mpi.h>\n";
        outFile << "#include <iostream>\n";
        outFile << "#include <csignal>\n";
        outFile << "#include \"V" << partitionModuleName << ".h\"\n";
        outFile << "#include \"verilated.h\"\n";
        outFile << "#include \"metro_mpi.cpp\"\n\n";

        outFile << "static V" << partitionModuleName << "* top = nullptr;\n";
        outFile << "static int rank = -1;\n";
        outFile << "static int size = -1;\n\n";
        outFile << "const int SHUTDOWN_TAG = 299;\n\n";

        outFile << "void cleanup(int signum) {\n";
        outFile << "    if (top) { top->final(); delete top; top = nullptr; }\n";
        outFile << "    mpi_finalize();\n";
        outFile << "    exit(signum);\n";
        outFile << "}\n\n";

        outFile << "// --- Initialization functions for each partition instance ---\n";
        for (const auto& pair : partitions) {
            const auto& partition = pair.second;
            outFile << "void initialize_partition_" << partition.instance_name << "() {\n";
            outFile << "    std::cout << \"Initializing partition " << partition.instance_name 
                    << " for Rank " << partition.mpi_rank << "...\" << std::endl;\n";
            for (const auto& port : partition.init_ports) {
                outFile << "    top->" << port.port_name << " = " << port.init_value << ";\n";
            }
            outFile << "}\n\n";
        }

        outFile << "// --- Modular MPI Send/Receive functions for each rank ---\n\n";
        for (int r : all_ranks) {
            if (r == 0) continue;

            outFile << "void receive_inputs_for_rank_" << r << "() {\n";
            bool receives_anything = false;
            for (const auto& [ranks, links] : commGraph) {
                if (ranks.second == r) {
                    receives_anything = true;
                    int sender = ranks.first;
                    std::string req_struct_type = "mpi_rank_" + std::to_string(sender) + "_to_" + std::to_string(r) + "_t";
                    outFile << "    // Receive from Rank " << sender << "\n";
                    // *** FIX: Call the new unique receive function name ***
                    outFile << "    " << req_struct_type << " req_from_" << sender << " = mpi_receive_from_rank_" << sender << "_to_" << r << "();\n";
                    for (const auto& link : links) {
                        outFile << "    top->" << link.receiver_port_name << " = req_from_" << sender << "." << link.sender_port_name << ";\n";
                    }
                }
            }
            if (!receives_anything) outFile << "    // This rank does not receive data from other partitions.\n";
            outFile << "}\n\n";

            outFile << "void send_outputs_from_rank_" << r << "() {\n";
            bool sends_anything = false;
            for (const auto& [ranks, links] : commGraph) {
                if (ranks.first == r) {
                    sends_anything = true;
                    int receiver = ranks.second;
                    std::string resp_struct_type = "mpi_rank_" + std::to_string(r) + "_to_" + std::to_string(receiver) + "_t";
                    outFile << "    // Send to Rank " << receiver << "\n";
                    outFile << "    {\n";
                    outFile << "        " << resp_struct_type << " resp_to_" << receiver << "{};\n";
                    for (const auto& link : links) {
                        outFile << "        resp_to_" << receiver << "." << link.sender_port_name << " = top->" << link.sender_port_name << ";\n";
                    }
                    outFile << "        mpi_send_rank_" << r << "_to_" << receiver << "(resp_to_" << receiver << ");\n";
                    outFile << "    }\n";
                }
            }
            if (!sends_anything) outFile << "    // This rank does not send data to other partitions.\n";
            outFile << "}\n\n";
        }

        outFile << "// High-level handler that coordinates the communication cycle\n";
        outFile << "void handle_requests() {\n";
        outFile << "    switch (rank) {\n";
        for (int r : all_ranks) {
            if (r == 0) continue;
            outFile << "        case " << r << ": {\n";
            outFile << "            send_outputs_from_rank_" << r << "();\n";
            // *** FIX: Corrected typo from 'from' to 'for' ***
            outFile << "            receive_inputs_for_rank_" << r << "();\n";
            outFile << "            top->eval();\n";
            outFile << "            break;\n";
            outFile << "        }\n";
        }
        outFile << "        default: break;\n";
        outFile << "    }\n";
        outFile << "}\n\n";

        outFile << "int main(int argc, char** argv) {\n";
        outFile << "    mpi_initialize();\n\n";
        outFile << "    top = new V" << partitionModuleName << ";\n\n";
        outFile << "    rank = getRank();\n";
        outFile << "    size = getSize();\n\n";
        outFile << "    std::cout << \"Partition '" << partitionModuleName << "' is alive on Rank \" << rank << \" of \" << size << std::endl;\n\n";
        outFile << "    switch (rank) {\n";
        for (const auto& pair : partitions) {
            const auto& partition = pair.second;
            outFile << "        case " << partition.mpi_rank << ": initialize_partition_" << partition.instance_name << "(); break;\n";
        }
        outFile << "        default: break;\n";
        outFile << "    }\n\n";
        outFile << "    top->eval();\n";
        outFile << "    MPI_Barrier(MPI_COMM_WORLD);\n\n";

        outFile << "    bool sim_end = false;\n";
        outFile << "    while (!sim_end) {\n";
        outFile << "        if (rank != 0) {\n";
        outFile << "             handle_requests();\n";
        outFile << "        }\n\n";
        outFile << "        int shutdown_flag = 0;\n";
        outFile << "        MPI_Status status;\n";
        outFile << "        MPI_Iprobe(0, SHUTDOWN_TAG, MPI_COMM_WORLD, &shutdown_flag, &status);\n";
        outFile << "        if (shutdown_flag) {\n";
        outFile << "            int dummy;\n";
        outFile << "            MPI_Recv(&dummy, 1, MPI_INT, 0, SHUTDOWN_TAG, MPI_COMM_WORLD, &status);\n";
        outFile << "            sim_end = true;\n";
        outFile << "        }\n";
        // outFile << "        MPI_Barrier(MPI_COMM_WORLD);\n";    //Removing for now to debug
        outFile << "    }\n\n";
        outFile << "    std::cout << \"Rank \" << rank << \": Shutting down.\" << std::endl;\n\n";
        outFile << "    cleanup(0);\n";
        outFile << "    return 0;\n";
        outFile << "}\n";
        outFile.close();
    }

public:
    void generate(const std::string& jsonFilePath, const std::string& partitionModuleName) {
        std::string outputDir = "metro_mpi";
        std::ifstream inputFile(jsonFilePath);
        if (!inputFile.is_open()) {
            std::cerr << "Error [MPIMainGenerator]: Could not open file " << jsonFilePath << std::endl;
            return;
        }

        try {
            json data = json::parse(inputFile);
            std::map<std::string, PartitionInfo> partitions;
            CommunicationGraph commGraph;
            std::set<std::tuple<int, int, std::string, std::string>> processed_physical_links;
            std::set<int> all_ranks;

            for (auto const& [instanceName, ports] : data["partitions"].items()) {
                PartitionInfo currentPartition;
                currentPartition.instance_name = instanceName;
                bool rank_found = false;
                for (const auto& port_json : ports) {
                    if (!rank_found) {
                        currentPartition.mpi_rank = port_json["mpi_rank"].get<int>();
                        rank_found = true;
                    }
                    if (port_json["type"] == "init") {
                        currentPartition.init_ports.push_back({
                            port_json["port_name"],
                            verilog_to_cpp_literal(port_json["connecting_wire"])
                        });
                    }
                    all_ranks.insert(port_json["mpi_rank"].get<int>());
                    if (port_json["active"] == "Yes") {
                        for (const auto& commPartner : port_json["with_whom_is_it_communicating"]) {
                            int current_rank = port_json["mpi_rank"].get<int>();
                            int partner_rank = commPartner["mpi_rank"].get<int>();
                            all_ranks.insert(partner_rank);
                            std::string current_port_name = port_json["port_name"];
                            std::string partner_port_name = commPartner["port"];
                            auto key = (current_rank < partner_rank) ? 
                                std::make_tuple(current_rank, partner_rank, current_port_name, partner_port_name) :
                                std::make_tuple(partner_rank, current_rank, partner_port_name, current_port_name);
                            if (processed_physical_links.count(key)) continue;
                            processed_physical_links.insert(key);
                            P2P_Link new_link;
                            if (port_json["direction"] == "in" || port_json["direction"] == "Input") {
                                new_link = {instanceName, current_rank, current_port_name, port_json["width"].get<int>(), commPartner["instance"], partner_rank, partner_port_name};
                            } else { 
                                new_link = {commPartner["instance"], partner_rank, partner_port_name, port_json["width"].get<int>(), instanceName, current_rank, current_port_name};
                            }
                            commGraph[{new_link.sender_rank, new_link.receiver_rank}].push_back(new_link);
                        }
                    }
                }
                partitions[instanceName] = currentPartition;
            }
            if (partitions.empty()) {
                throw std::runtime_error("No partitions found in the JSON file.");
            }
            generateStandaloneMain(partitionModuleName, partitions, commGraph, all_ranks, outputDir);
        } catch (const std::exception& e) {
            std::cerr << "An error occurred in MPIMainGenerator: " << e.what() << std::endl;
            return;
        }
    }
};

#endif // V3METRO_MPI_PART_LIB_H
