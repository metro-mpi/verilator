#ifndef V3METRO_MPI_MAIN_RANK_0_H
#define V3METRO_MPI_MAIN_RANK_0_H

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <sstream>
#include <stdexcept>
#include <algorithm>

// This header requires the nlohmann/json library for JSON parsing.
#include "json.h"

using json = nlohmann::json;

/**
 * @class Rank0MainGenerator
 * @brief Generates a C++ harness for the rank 0 (system) process.
 * @details This class creates a header file (`rank0_harness.h`) containing the
 * necessary DPI function implementations and MPI helper functions. The user can then
 * include this harness into their own custom testbench (e.g., sim.cpp) to enable
 * MPI-based co-simulation without having to rewrite their main simulation loop.
 */
class Rank0MainGenerator {
private:
    // Holds detailed information for a single port of the partition module.
    struct PortDetail {
        std::string name;
        int width;
        std::string direction;

        bool operator<(const PortDetail& other) const {
            return name < other.name;
        }
    };

    // Maps a partition's MPI rank to a vector of its ports that
    // communicate directly with the system (rank 0).
    using SystemCommMap = std::map<int, std::vector<PortDetail>>;

public:
    /**
     * @brief The main entry point for the generator.
     * @param jsonFilePath Path to the `partition_report.json` file.
     * @param partitionModuleName The name of the module that has been partitioned.
     */
    void generate(const std::string& jsonFilePath, const std::string& partitionModuleName) {
        // Open and parse the JSON report which contains all analysis results.
        std::ifstream inputFile(jsonFilePath);
        if (!inputFile.is_open()) {
            throw std::runtime_error("Error [Rank0MainGenerator]: Could not open JSON file " + jsonFilePath);
        }
        json data = json::parse(inputFile);

        SystemCommMap sendsToSystem;
        SystemCommMap receivesFromSystem;
        std::set<int> partitionRanks;
        std::vector<PortDetail> allPorts;

        // --- Step 1: Parse the JSON report ---
        bool allPortsCaptured = false;
        for (auto const& [instanceName, ports] : data["partitions"].items()) {
            int current_rank = -1;
            for (const auto& port : ports) {
                if (current_rank == -1) {
                    current_rank = port["mpi_rank"].get<int>();
                    partitionRanks.insert(current_rank);
                }
                if (!allPortsCaptured) {
                    allPorts.push_back({port["port_name"], port["width"], port["direction"]});
                }
                for (const auto& commPartner : port["with_whom_is_it_communicating"]) {
                    if (commPartner["mpi_rank"] == 0) {
                        std::string dir = port["direction"];
                        if (dir == "out" || dir == "Output") {
                            sendsToSystem[current_rank].push_back({port["port_name"], port["width"], dir});
                        } else {
                            receivesFromSystem[current_rank].push_back({port["port_name"], port["width"], dir});
                        }
                    }
                }
            }
            allPortsCaptured = true;
        }
        
        std::sort(allPorts.begin(), allPorts.end());

        // --- Step 2: Generate the `rank0_harness.h` file ---
        std::string outHarnessFileName = "metro_mpi/rank0_harness.h";
        std::ofstream outHarnessFile(outHarnessFileName);
        if (!outHarnessFile.is_open()) {
            throw std::runtime_error("Error [Rank0MainGenerator]: Could not open output file " + outHarnessFileName);
        }

        outHarnessFile << "// Generated by Metro-MPI for Rank 0 (System) Process\n";
        outHarnessFile << "// Include this file in your custom C++ testbench (e.g., sim.cpp)\n\n";
        outHarnessFile << "#ifndef METRO_MPI_RANK0_HARNESS_H\n";
        outHarnessFile << "#define METRO_MPI_RANK0_HARNESS_H\n\n";
        outHarnessFile << "#include <mpi.h>\n";
        outHarnessFile << "#include \"metro_mpi.cpp\"\n\n";

        // Generate the DPI function implementation
        outHarnessFile << "extern \"C\" void dpi_" << partitionModuleName << "(\n";
        outHarnessFile << "    int partition_id";
        for(const auto& port : allPorts) {
            std::string c_type = (port.width > 32) ? "long long" : "int";
            std::string direction_spec = (port.direction == "out" || port.direction == "Output") ? "* " : "";
            outHarnessFile << ",\n    " << c_type << " " << direction_spec << port.name;
        }
        outHarnessFile << ") {\n";
        outHarnessFile << "    switch (partition_id) {\n";
        for (int rank : partitionRanks) {
            outHarnessFile << "        case " << rank << ": {\n";
            if (receivesFromSystem.count(rank)) {
                outHarnessFile << "            mpi_rank_0_to_" << rank << "_t req;\n";
                for (const auto& port : receivesFromSystem.at(rank)) {
                    outHarnessFile << "            req." << port.name << " = " << port.name << ";\n";
                }
                outHarnessFile << "            mpi_send_rank_0_to_" << rank << "(req);\n";
            }
            if (sendsToSystem.count(rank)) {
                outHarnessFile << "            mpi_rank_" << rank << "_to_0_t resp = mpi_receive_from_rank_" << rank << "_to_0();\n";
                for (const auto& port : sendsToSystem.at(rank)) {
                    outHarnessFile << "            *" << port.name << " = resp." << port.name << ";\n";
                }
            }
            outHarnessFile << "            break;\n";
            outHarnessFile << "        }\n";
        }
        outHarnessFile << "        default: {\n";
        outHarnessFile << "            break;\n";
        outHarnessFile << "        }\n";
        outHarnessFile << "    }\n";
        outHarnessFile << "}\n\n";

        // Generate the shutdown helper function
        outHarnessFile << "void metro_mpi_broadcast_shutdown() {\n";
        outHarnessFile << "    std::cout << \"[Rank 0] Broadcasting shutdown signal.\" << std::endl;\n";
        outHarnessFile << "    const int SHUTDOWN_TAG = 299;\n";
        outHarnessFile << "    for (int rank : {";
        bool first = true;
        for(int rank : partitionRanks) {
            if(!first) outHarnessFile << ", ";
            outHarnessFile << rank;
            first = false;
        }
        outHarnessFile << "}) {\n";
        outHarnessFile << "        int dummy = 1;\n";
        outHarnessFile << "        MPI_Send(&dummy, 1, MPI_INT, rank, SHUTDOWN_TAG, MPI_COMM_WORLD);\n";
        outHarnessFile << "    }\n";
        outHarnessFile << "}\n\n";
        outHarnessFile << "#endif // METRO_MPI_RANK0_HARNESS_H\n";
        outHarnessFile.close();
        std::cout << "[Metro-MPI] Successfully generated Rank 0 harness: " << outHarnessFileName << std::endl;

        // --- Step 3: Generate the README_integration.txt file ---
        std::string outReadmeFileName = "metro_mpi/README_integration.txt";
        std::ofstream outReadmeFile(outReadmeFileName);
        if (!outReadmeFile.is_open()) {
            throw std::runtime_error("Error [Rank0MainGenerator]: Could not open output file " + outReadmeFileName);
        }
        
        outReadmeFile << "Metro-MPI: Instructions for Integrating with Your Custom Testbench (e.g., sim.cpp)\n";
        outReadmeFile << "==================================================================================\n\n";
        outReadmeFile << "To enable MPI-based co-simulation, you need to make three small changes to your main C++ testbench file.\n\n";
        outReadmeFile << "1. ADD THIS INCLUDE AT THE TOP OF YOUR FILE:\n";
        outReadmeFile << "-------------------------------------------\n";
        outReadmeFile << "#include \"metro_mpi/rank0_harness.h\"\n\n\n";
        
        outReadmeFile << "2. ADD THIS LINE AT THE START OF YOUR main() FUNCTION:\n";
        outReadmeFile << "-----------------------------------------------------\n";
        outReadmeFile << "int main(int argc, char **argv) {\n";
        outReadmeFile << "    Verilated::commandArgs(argc, argv);\n";
        outReadmeFile << "    mpi_initialize(); // <-- ADD THIS LINE\n";
        outReadmeFile << "    \n";
        outReadmeFile << "    // ... your existing setup code ...\n";
        outReadmeFile << "}\n\n\n";

        outReadmeFile << "3. ADD THESE LINES AT THE END OF YOUR main() FUNCTION, BEFORE EXITING:\n";
        outReadmeFile << "---------------------------------------------------------------------\n";
        outReadmeFile << "    // ... your simulation loop finishes ...\n";
        outReadmeFile << "    \n";
        outReadmeFile << "    metro_mpi_broadcast_shutdown(); // <-- ADD THIS LINE to signal other ranks to exit.\n";
        outReadmeFile << "    \n";
        outReadmeFile << "    top->final();\n";
        outReadmeFile << "    trace->close();\n";
        outReadmeFile << "    delete top;\n";
        outReadmeFile << "    delete trace;\n";
        outReadmeFile << "    \n";
        outReadmeFile << "    mpi_finalize(); // <-- ADD THIS LINE to clean up MPI.\n";
        outReadmeFile << "    return 0;\n";
        outReadmeFile << "}\n\n\n";
        
        outReadmeFile << "4. COMPILE YOUR TESTBENCH WITH AN MPI COMPILER:\n";
        outReadmeFile << "------------------------------------------------\n";
        outReadmeFile << "When you build your final executable, you must use an MPI C++ compiler wrapper, such as 'mpic++'.\n";
        outReadmeFile << "Example Makefile rule:\n";
        outReadmeFile << "    make CXX=mpic++ LINK=mpic++ -C $(OBJ_DIR) -f Vyour_top_module.mk\n";

        outReadmeFile.close();
        std::cout << "[Metro-MPI] Successfully generated integration instructions: " << outReadmeFileName << std::endl;
    }
};

#endif // V3METRO_MPI_MAIN_RANK_0_H
