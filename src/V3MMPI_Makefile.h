//This is going to make the Makefile which will build the partition library and do the simulation

#ifndef V3METRO_MPI_MK_H
#define V3METRO_MPI_MK_H

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <set>
#include <sstream>

// ======================================================================
// MakefileGenerator Class
// Parses an existing Verilator command and generates a new Makefile
// for a specific partition in the user-specified format.
// ======================================================================

class MakefileGenerator {
private:
    // Represents a single Verilator command-line argument.
    struct VerilatorOption {
        std::string name;
        std::set<std::string> aliases;
        std::string description;
        bool hasValue;
    };

    // A class that holds a database of all known Verilator command-line options.
    class VerilatorOptionsDb {
    public:
        VerilatorOptionsDb();
        const VerilatorOption* findOption(const std::string& optionName) const;
    private:
        std::vector<VerilatorOption> m_options;
        void initialize();
    };

    // Helper function to parse a single command string into a vector
    std::vector<std::string> parseCommandString(const std::string& command) {
        std::vector<std::string> args;
        std::stringstream ss(command);
        std::string arg;
        // This simple parser won't handle quoted arguments with spaces.
        while (ss >> arg) {
            args.push_back(arg);
        }
        return args;
    }


public:
    /**
     * @brief Main entry point to generate the Makefile.
     * @param originalCommand The original command line for the full design as a single string.
     * @param partitionModuleName The name of the top module for the partition.
     * @param partitionVerilogFiles A vector of strings with the full paths to the Verilog files for the partition.
     */
    void generate(const std::string& originalCommand,
                  const std::string& partitionModuleName,
                  const std::vector<std::string>& partitionVerilogFiles) {

        std::vector<std::string> originalArgs = parseCommandString(originalCommand);

        std::cout << "\n[Metro-MPI] Generating Makefile for partition '" << partitionModuleName << "'..." << std::endl;

        VerilatorOptionsDb db;
        std::stringstream verilatorFlags;

        // --- 1. Parse the original command line to extract pass-through flags ---
        for (size_t i = 1; i < originalArgs.size(); ++i) {
            std::string currentArg = originalArgs[i];
            const VerilatorOption* opt = db.findOption(currentArg);

            if (opt) {
                // We only care about flags that should be passed through to the partition's verilate command.
                if (opt->name == "-CFLAGS" || opt->name == "-LDFLAGS" || opt->name == "-D<var>[=<value>]" || opt->name == "-y" ||
                    opt->name == "--timing" || opt->name == "--trace" || opt->name == "-Wall" || 
                    opt->name.rfind("-Wno-", 0) == 0 || opt->name == "--unroll-count") {
                    
                    verilatorFlags << currentArg;
                    if (opt->hasValue) {
                        if (i + 1 < originalArgs.size()) {
                            verilatorFlags << " " << originalArgs[++i];
                        }
                    }
                    verilatorFlags << " ";
                }
            }
        }

        // --- 2. Construct the new Makefile content in the desired format ---
        std::stringstream makefileContent;
        
        makefileContent << "# Makefile for partition: " << partitionModuleName << "\n";
        makefileContent << "# Generated by Metro-MPI\n\n";

        // Variables
        makefileContent << "SRC_FILES = \\\n";
        for(const auto& file : partitionVerilogFiles) {
            makefileContent << "\t" << file << " \\\n";
        }
        makefileContent << "\n";

        makefileContent << "obj_dir ?= obj_dir_" << partitionModuleName << "\n";
        makefileContent << "TOP = V" << partitionModuleName << "\n";
        makefileContent << "top_mod ?= " << partitionModuleName << "\n";
        makefileContent << "CXX_SOURCES = metro_mpi/" << partitionModuleName << "_main.cpp\n";
        makefileContent << "VERILATOR_FLAGS = " << verilatorFlags.str() << "\n";
        makefileContent << "LOG_FILE = build_library.log\n\n";

        // Targets
        makefileContent << ".PHONY: library verilate build clean\n\n";

        makefileContent << "# Main target to build the library and log the entire process.\n";
        makefileContent << "library: build\n";
        makefileContent << "\t@echo \"Build process for " << partitionModuleName << " complete.\"\n";
        makefileContent << "\t@echo \"Log available in $(LOG_FILE)\"\n\n";

        makefileContent << "verilate:\n";
        makefileContent << "\t@echo \"Starting build at $$(date)\" > $(LOG_FILE)\n";
        makefileContent << "\t@echo \"\\n== == == 4. Elaborating " << partitionModuleName << " with MPI...\" >> $(LOG_FILE) 2>&1\n";
        makefileContent << "\t@(verilator -cc $(SRC_FILES) \\\n";
        makefileContent << "\t\t--exe $(CXX_SOURCES) \\\n";
        makefileContent << "\t\t--Mdir $(obj_dir) \\\n";
        makefileContent << "\t\t--top-module $(top_mod) \\\n";
        makefileContent << "\t\t$(VERILATOR_FLAGS)) >> $(LOG_FILE) 2>&1\n\n";

        makefileContent << "build: verilate\n";
        makefileContent << "\t@echo \"\\n== == == 5. Making the library...\" >> $(LOG_FILE) 2>&1\n";
        makefileContent << "\t@(make CXX=mpic++ LINK=mpic++ -C $(obj_dir) -f $(TOP).mk $(TOP)) >> $(LOG_FILE) 2>&1\n";
        makefileContent << "\t@echo \"\\nBuild finished at $$(date)\" >> $(LOG_FILE)\n\n";

        makefileContent << "clean:\n";
        makefileContent << "\t@echo \"Cleaning build files...\"\n";
        makefileContent << "\t@rm -rf $(obj_dir) $(LOG_FILE)\n";


        // --- 3. Write the Makefile ---
        std::string makefileName = "metro_mpi/Makefile." + partitionModuleName;
        std::ofstream outfile(makefileName);
        if (outfile.is_open()) {
            outfile << makefileContent.str();
            outfile.close();
            std::cout << "  --> Successfully wrote Makefile to '" << makefileName << "'\n";
        } else {
            std::cerr << "  --> ERROR: Could not open file to write Makefile: " << makefileName << "\n";
        }
    }
};


// ======================================================================
// VerilatorOptionsDb Implementation (Private to this file)
// ======================================================================

MakefileGenerator::VerilatorOptionsDb::VerilatorOptionsDb() {
    initialize();
}

const MakefileGenerator::VerilatorOption* MakefileGenerator::VerilatorOptionsDb::findOption(const std::string& optionName) const {
    for (const auto& opt : m_options) {
        if (opt.name == optionName || opt.aliases.count(optionName)) {
            return &opt;
        }
    }
    std::string alternativeOption;
    if (optionName.rfind("--", 0) == 0) {
        alternativeOption = optionName.substr(1);
    } else if (optionName.rfind("-", 0) == 0 && optionName.rfind("--", 0) != 0) {
        alternativeOption = "-" + optionName;
    }
    if (!alternativeOption.empty()) {
        for (const auto& opt : m_options) {
            if (opt.name == alternativeOption || opt.aliases.count(alternativeOption)) {
                return &opt;
            }
        }
    }
    if (optionName.rfind("-D", 0) == 0) return findOption("-D<var>[=<value>]");
    if (optionName.rfind("-G", 0) == 0) return findOption("-G<name>=<value>");
    if (optionName.rfind("+define+", 0) == 0) return findOption("+define+<var>=<value>");
    if (optionName.rfind("+incdir+", 0) == 0) return findOption("-y");
    if (optionName.rfind("+libext+", 0) == 0) return findOption("+libext+<ext>+[ext]...");
    return nullptr;
}

void MakefileGenerator::VerilatorOptionsDb::initialize() {
    m_options = {
        {"--mmpi-o1", {}, "Custom Metro-MPI: Enable optimization level 1", false},
        {"--d1", {}, "Custom Metro-MPI: Enable debug level 1", false},
        {"<file.v>", {}, "Verilog package, module, and top module filenames", false},
        {"<file.c/cc/cpp>", {}, "Optional C++ files to compile in", false},
        {"<file.a/o/so>", {}, "Optional C++ files to link in", false},
        {"+1364-1995ext+<ext>", {}, "Use Verilog 1995 with file extension <ext>", true},
        {"+1364-2001ext+<ext>", {}, "Use Verilog 2001 with file extension <ext>", true},
        {"+1364-2005ext+<ext>", {}, "Use Verilog 2005 with file extension <ext>", true},
        {"+1800-2005ext+<ext>", {}, "Use SystemVerilog 2005 with file extension <ext>", true},
        {"+1800-2009ext+<ext>", {}, "Use SystemVerilog 2009 with file extension <ext>", true},
        {"+1800-2012ext+<ext>", {}, "Use SystemVerilog 2012 with file extension <ext>", true},
        {"+1800-2017ext+<ext>", {}, "Use SystemVerilog 2017 with file extension <ext>", true},
        {"+1800-2023ext+<ext>", {}, "Use SystemVerilog 2023 with file extension <ext>", true},
        {"-f", {}, "Parse arguments from a file", true},
        {"-F", {}, "Parse arguments from a file, relatively", true},
        {"--binary", {}, "Build model binary", false},
        {"--cc", {}, "Create C++ output", false},
        {"--sc", {}, "Create SystemC output", false},
        {"--lint-only", {}, "Lint, but do not make output", false},
        {"-E", {}, "Preprocess, but do not compile", false},
        {"--json-only", {}, "Create JSON parser output (.tree.json and .meta.json)", false},
        {"--xml-only", {}, "Create XML parser output", false},
        {"--build", {}, "Build model executable/library after Verilation", false},
        {"--build-dep-bin", {"-bin"}, "Override build dependency Verilator binary", true},
        {"--build-jobs", {}, "Parallelism for --build", true},
        {"-j", {}, "Parallelism for build-jobs/--verilate-jobs", true},
        {"--compiler", {}, "Tune for specified C++ compiler", true},
        {"--compiler-include", {}, "Include additional header in the precompiled one", true},
        {"--exe", {}, "Link to create executable", false},
        {"-o", {}, "Name of final executable", true},
        {"--make", {}, "Generate scripts for specified build tool", true},
        {"-MAKEFLAGS", {}, "Arguments to pass to make during --build", true},
        {"--verilate-jobs", {}, "Job threads for Verilation stage", true},
        {"--no-verilate", {}, "Skip Verilation and just compile previously Verilated code", false},
        {"-CFLAGS", {}, "C++ compiler arguments for makefile", true},
        {"-LDFLAGS", {}, "Linker pre-object arguments for makefile", true},
        {"-FI", {}, "Force include of a file", true},
        {"-D<var>[=<value>]", {}, "Set preprocessor define", false},
        {"+define+<var>=<value>", {}, "Set preprocessor define", false},
        {"-U<var>", {}, "Undefine preprocessor define", true},
        {"--default-language", {}, "Default language to parse", true},
        {"--language", {}, "Default language standard to parse", true},
        {"-sv", {}, "Enable SystemVerilog parsing", false},
        {"+systemverilogext+<ext>", {}, "Synonym for +1800-2023ext+<ext>", true},
        {"-v", {}, "Verilog library", true},
        {"-y", {"-I", "+incdir+<dir>"}, "Directory to search for includes", true},
        {"+libext+<ext>+[ext]...", {}, "Extensions for finding modules", true},
        {"--pp-comments", {}, "Show preprocessor comments with -E", false},
        {"--dump-defines", {}, "Show preprocessor defines with -E", false},
        {"--main", {}, "Generate C++ main() file", false},
        {"--main-top-name", {}, "Specify top name passed to Verilated model in C++ main", true},
        {"--savable", {}, "Enable model save-restore", false},
        {"--timing", {}, "Enable timing support", false},
        {"--no-timing", {}, "Disable timing support", false},
        {"--timescale", {}, "Sets default timescale", true},
        {"--timescale-override", {}, "Overrides all timescales", true},
        {"--trace", {}, "Enable waveform creation", false},
        {"--trace-fst", {}, "Enable FST waveform creation", false},
        {"--trace-coverage", {}, "Enable tracing of coverage", false},
        {"--trace-depth", {}, "Depth of tracing", true},
        {"--trace-max-array", {}, "Maximum array depth for tracing", true},
        {"--trace-max-width", {}, "Maximum bit width for tracing", true},
        {"--trace-params", {}, "Enable tracing of parameters", false},
        {"--trace-structs", {}, "Enable tracing structure names", false},
        {"--trace-threads", {}, "Enable FST waveform creation on separate threads", true},
        {"--no-trace-top", {}, "Do not emit traces for signals in the top module generated by verilator", false},
        {"--trace-underscore", {}, "Enable tracing of signals that start with an underscore", false},
        {"--coverage", {}, "Enable all coverage", false},
        {"--coverage-line", {}, "Enable line coverage", false},
        {"--coverage-toggle", {}, "Enable toggle coverage", false},
        {"--coverage-user", {}, "Enable SVL user coverage", false},
        {"--coverage-max-width", {}, "Maximum array depth for coverage", true},
        {"--coverage-underscore", {}, "Enable coverage of signals that start with an underscore", false},
        {"-O0", {}, "Disable optimizations", false},
        {"-O3", {}, "High-performance optimizations", false},
        {"-O<optimization-letter>", {}, "Selectable optimizations", true},
        {"-fno-<optimization>", {}, "Disable internal optimization stage", true},
        {"--inline-mult", {}, "Tune module inlining", true},
        {"--unroll-count", {}, "Tune maximum loop iterations", true},
        {"--unroll-stmts", {}, "Tune maximum loop body size", true},
        {"--debug", {}, "Enable debugging", false},
        {"--debug-check", {}, "Enable debugging assertions", false},
        {"--no-debug-leak", {}, "Disable leaking memory in-debug mode", false},
        {"--debugi", {}, "Enable debugging at a specified level", true},
        {"--debugi-<srcfile>", {}, "Enable debugging a source file at a level", true},
        {"--dump-tree", {}, "Enable dumping Ast tree files", false},
        {"--dump-graph", {}, "Enable dumping V3Graphs to dot files", false},
        {"--gdb", {}, "Run Verilator under GDB interactively", false},
        {"--gdbbt", {}, "Run Verilator under GDB for backtrace", false},
        {"--rr", {}, "Run Verilator and record with rr", false},
        {"--valgrind", {}, "Run Verilator under valgrind", false},
        {"--runtime-debug", {}, "Enable model runtime debugging", false},
        {"-Wall", {}, "Enable all style warnings", false},
        {"-Werror-<message>", {}, "Convert warnings to errors", true},
        {"-Wfuture-<message>", {}, "Disable unknown message warnings", true},
        {"-Wno-<message>", {}, "Disable warning", true},
        {"-Wno-fatal", {}, "Disable fatal exit on warnings", false},
        {"-Wpedantic", {}, "Warn on compliance-test issues", false},
        {"-Wwarn-<message>", {}, "Enable specified warning message", true},
        {"--error-limit", {}, "Abort after this number of errors", true},
        {"--help", {}, "Show this help", false},
        {"--version", {}, "Show program version and exits", false},
        {"-V", {}, "Verbose version and config", false},
        {"--top-module", {"--top"}, "Name of top-level input module", true},
        {"-G<name>=<value>", {"-pvalue+<name>=<value>"}, "Overwrite top-level parameter", false},
        {"--prefix", {}, "Name of top-level class", true},
        {"--Mdir", {}, "Name of output object directory", true},
        {"--vpi", {}, "Enable VPI compiles", false},
        {"--threads", {}, "Enable multithreading", true},
        {"--clk", {}, "Mark specified signal as clock", true},
        {"--no-clk", {}, "Prevent marking specified signal as clock", true},
        {"--public", {}, "Mark signals as public; see docs", false},
        {"--public-flat-rw", {}, "Mark all variables, etc as public_flat_rw", false},
        {"--hierarchical", {}, "Enable hierarchical Verilation", false},
        {"--lib-create", {}, "Create a DPI library", true},
        {"--protect-lib", {}, "Create a DPI protected library", true},
        {"--x-assign", {}, "Assign non-initial Xs to this value", true},
        {"--x-initial", {}, "Assign initial Xs to this value", true},
        {"--x-initial-edge", {}, "Enable initial X->0 and X->1 edge triggers", false},
    };
}

#endif // V3METRO_MPI_MK_H
